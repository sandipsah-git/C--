Lab 1. Program to illustrate Malloc function 
#include<iostream>
#include<cstdlib>
using namespace std;
int main() {
    int *ptr;
    int n;
    cout << "Enter the number of elements: ";
    cin >> n;
    // Allocating memory using malloc
    ptr = (int*)malloc(n * sizeof(int));
    if (ptr == NULL) {
        cout << "Memory allocation failed." << endl;
        return 1;
    }
    cout << "Memory allocation successful." << endl;
    // Use the allocated memory here
    // Deallocating memory
    free(ptr);
    return 0;
}









Lab 2. Program to illustrate Calloc function 
#include<iostream>
#include<cstdlib>
using namespace std;
int main() {
    int *ptr;
    int n;
    cout << "Enter the number of elements: ";
    cin >> n;
    // Allocating memory using calloc
    ptr = (int*)calloc(n, sizeof(int));
    if (ptr == NULL) {
        cout << "Memory allocation failed." << endl;
        return 1;
    }
    cout << "Memory allocation successful." << endl;
    // Use the allocated memory here

    // Deallocating memory
    free(ptr);
    return 0;
}








Lab 3. Program to illustrate Realloc function
#include<iostream>
#include<cstdlib>
using namespace std;
int main() {
    int *ptr;
    int n;
    cout << "Enter the initial number of elements: ";
    cin >> n;
    // Allocating memory using malloc
    ptr = (int*)malloc(n * sizeof(int));
    if (ptr == NULL) {
        cout << "Memory allocation failed." << endl;
        return 1;
    }
    cout << "Memory allocation successful." << endl;
    // Use the allocated memory here

    // Reallocating memory
    int newSize;
    cout << "Enter the new size: ";
    cin >> newSize;
    ptr = (int*)realloc(ptr, newSize * sizeof(int));
    cout << "Memory reallocation successful." << endl;
    // Use the reallocated memory here

    // Deallocating memory
    free(ptr);
    return 0;
}




Lab 4. Program to illustrate Stack operation
#include<iostream>
using namespace std;
const int MAX_SIZE = 100;
int stack[MAX_SIZE];
int top = -1;
void push(int value) {
    if (top == MAX_SIZE - 1) {
        cout << "Stack overflow!" << endl;
        return;
    }
    stack[++top] = value;
}
int pop() {
    if (top == -1) {
        cout << "Stack underflow!" << endl;
        return -1;
    }
    return stack[top--];
}
int peek() {
    if (top == -1) {
        cout << "Stack is empty!" << endl;
        return -1;
    }
    return stack[top];
}
bool isEmpty() {
    return top == -1;
}
int main() {
    push(10);
    push(20);
    push(30);

    cout << "Top element: " << peek() << endl;
    cout << "Popped element: " << pop() << endl;
    cout << "Popped element: " << pop() << endl;
    cout << "Is the stack empty? " << (isEmpty() ? "Yes" : "No") << endl;
    return 0;
}


Lab 5. Program to evaluate infix operation 
#include<iostream>
#include<stack>
#include<string>
using namespace std;
// Function to check if a character is an operator
bool isOperator(char op) {
    return (op == '+' || op == '-' || op == '*' || op == '/');
}
// Function to perform arithmetic operation	
int performOperation(int operand1, int operand2, char op) {
    switch (op) {
        case '+': return operand1 + operand2;
        case '-': return operand1 - operand2;
        case '*': return operand1 * operand2;
        case '/': return operand1 / operand2;
        default: return 0;
    }
}
// Function to evaluate infix expression
int evaluateInfix(const string& infix) {
    stack<int> operands;
    stack<char> operators;
    for (char ch : infix) {
        if (isdigit(ch)) {
            operands.push(ch - '0');
        } else if (isOperator(ch)) {
            while (!operators.empty() && operators.top() != '(' && 
                    ((ch == '+' || ch == '-') || (ch == '*' || ch == '/') && (operators.top() == '*' || operators.top() == '/'))) {
                int operand2 = operands.top();
                operands.pop();
                int operand1 = operands.top();
                operands.pop();
                char oper = operators.top();
                operators.pop();
                operands.push(performOperation(operand1, operand2, oper));
            }
            operators.push(ch);
        } else if (ch == '(') {
            operators.push(ch);
        } else if (ch == ')') {
            while (!operators.empty() && operators.top() != '(') {
                int operand2 = operands.top();
                operands.pop();
                int operand1 = operands.top();
                operands.pop();
                char oper = operators.top();
                operators.pop();
                operands.push(performOperation(operand1, operand2, oper));
            }
            operators.pop();  // Pop '('
        }
    }
    while (!operators.empty()) {
        int operand2 = operands.top();
        operands.pop();
        int operand1 = operands.top();
        operands.pop();
        char oper = operators.top();
        operators.pop();
        operands.push(performOperation(operand1, operand2, oper));
    }
    return operands.top();
}
int main() {
    string infixExpression = "3 + 5 * ( 2 - 8 ) / 4";
    cout << "Result: " << evaluateInfix(infixExpression) << endl;
    return 0;
}
Lab 6. Program to evaluate postfix operation
#include<iostream>
#include<stack>
#include<string>
using namespace std;
// Function to check if a character is an operand
bool isOperand(char ch) {
    return isdigit(ch);
}
// Function to perform arithmetic operation
int performOperation(int operand1, int operand2, char op) {
    switch (op) {
        case '+': return operand1 + operand2;
        case '-': return operand1 - operand2;
        case '*': return operand1 * operand2;
        case '/': return operand1 / operand2;
        default: return 0;
    }
}
// Function to evaluate postfix expression
int evaluatePostfix(const string& postfix) {
    stack<int> operands;
    for (char ch : postfix) {
        if (isOperand(ch)) {
            operands.push(ch - '0');
        } else {
            int operand2 = operands.top();
            operands.pop();
            int operand1 = operands.top();
            operands.pop();
            operands.push(performOperation(operand1, operand2, ch));
        }
    }
    return operands.top();
}
int main() {
    string postfixExpression = "35*28-4/+";
    cout << "Result: " << evaluatePostfix(postfixExpression) << endl;
    return 0;
}

Lab 7. Program to evaluate prefix operation 
#include<iostream>
#include<stack>
#include<string>
using namespace std;
// Function to check if a character is an operand
bool isOperand(char ch) {
    return isdigit(ch);
}
// Function to perform arithmetic operation
int performOperation(int operand1, int operand2, char op) {
    switch (op) {
        case '+': return operand1 + operand2;
        case '-': return operand1 - operand2;
        case '*': return operand1 * operand2;
        case '/': return operand1 / operand2;
        default: return 0;
    }
}
// Function to evaluate prefix expression
int evaluatePrefix(const string& prefix) {
    stack<int> operands;
    for (int i = prefix.size() - 1; i >= 0; --i) {
        char ch = prefix[i];
        if (isOperand(ch)) {
            operands.push(ch - '0');
        } else {
            int operand1 = operands.top();
            operands.pop();
            int operand2 = operands.top();
            operands.pop();
            operands.push(performOperation(operand1, operand2, ch));
        }
    }
    return operands.top();
}
int main() {
    string prefixExpression = "+*35/284";
    cout << "Result: " << evaluatePrefix(prefixExpression) << endl;
    return 0;
}
Lab 8. Program to illustrate linear queue 
#include<iostream>
using namespace std;
const int MAX_SIZE = 5;
int queueArr[MAX_SIZE];
int front = -1;
int rear = -1;
bool isFull() {
    return (rear == MAX_SIZE - 1);
}
bool isEmpty() {
    return (front == -1 || front > rear);
}
void enqueue(int value) {
    if (isFull()) {
        cout << "Queue is full. Cannot enqueue." << endl;
        return;
    }
    if (front == -1) {
        front = 0;
    }
    queueArr[++rear] = value;
    cout << value << " enqueued to the queue." << endl;
}
int dequeue() {
    if (isEmpty()) {
        cout << "Queue is empty. Cannot dequeue." << endl;
        return -1;
    }
    int value = queueArr[front++];
    cout << value << " dequeued from the queue." << endl;
    if (front > rear) {
        front = rear = -1;
    }
    return value;
}
int main() {
    enqueue(10);
    enqueue(20);
    enqueue(30);
    dequeue();
    dequeue();
    dequeue();
    return 0; }
Lab 9. Program to illustrate circular queue 
#include<iostream>
using namespace std;
const int MAX_SIZE = 5;
int queueArr[MAX_SIZE];
int front = -1;
int rear = -1;
bool isFull() {
    return ((rear + 1) % MAX_SIZE == front);
}
bool isEmpty() {
    return (front == -1 && rear == -1);
}
void enqueue(int value) {
    if (isFull()) {
        cout << "Queue is full. Cannot enqueue." << endl;
        return;
    }
    if (isEmpty()) {
        front = rear = 0;
    } else {
        rear = (rear + 1) % MAX_SIZE;
    }
    queueArr[rear] = value;
    cout << value << " enqueued to the circular queue." << endl;
}
int dequeue() {
    if (isEmpty()) {
        cout << "Queue is empty. Cannot dequeue." << endl;
        return -1;
    }
    int value = queueArr[front];

    if (front == rear) {
        front = rear = -1;
    } else {
        front = (front + 1) % MAX_SIZE;
    }
    cout << value << " dequeued from the circular queue." << endl;
    return value;
}
int main() {
    enqueue(10);
    enqueue(20);
    enqueue(30);
    dequeue();
    dequeue();
    dequeue();
    return 0; }
Lab 10. Program to illustrate priority queue 
#include<iostream>
#include<queue>
using namespace std;
int main() {
    priority_queue<int> pq;
    pq.push(30);
    pq.push(10);
    pq.push(20);
    cout << "Priority Queue elements: ";
    while (!pq.empty()) {
        cout << pq.top() << " ";
        pq.pop();
    }
    return 0;
}














Lab 11. Program to illustrate direct recursion 
#include<iostream>
using namespace std;
void directRecursion(int n) {
    if (n > 0) {
        cout << n << " ";
        directRecursion(n - 1);
    }
}
int main() {
    directRecursion(5);
    return 0;
}






















Lab 12. Program to illustrate indirect recursion 
#include<iostream>
using namespace std;

void indirectRecursionB(int n);

void indirectRecursionA(int n) {
    if (n > 0) {
        cout << n << " ";
        indirectRecursionB(n - 1);
    }
}

void indirectRecursionB(int n) {
    if (n > 1) {
        cout << n << " ";
        indirectRecursionA(n / 2);
    }
}

int main() {
    indirectRecursionA(20);
    return 0;
}



Lab 13. Program to illustrate tail recursion 
#include<iostream>
using namespace std;

void tailRecursion(int n) {
    if (n > 0) {
        cout << n << " ";
        tailRecursion(n - 1);
    }
}

int main() {
    tailRecursion(5);
    return 0;
}




















L14. Program to find factorial
#include<iostream>
using namespace std;

int factorial(int n) {
    if (n == 0 || n == 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

int main() {
    int num = 5;
    cout << "Factorial of " << num << " is: " << factorial(num) << endl;
    return 0;
}
15. Program to find fabonacci 
#include<iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int num = 6;
    cout << "Fibonacci sequence up to " << num << " terms: ";
    for (int i = 0; i < num; ++i) {
        cout << fibonacci(i) << " ";
    }
    cout << endl;
    return 0;
}
16. Program to find GCD 
#include<iostream>
using namespace std;

int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}

int main() {
    int num1 = 24, num2 = 18;
    cout << "GCD of " << num1 << " and " << num2 << " is: " << gcd(num1, num2) << endl;
    return 0;
}
17. Program to illustrate tower of Hanoi 
#include<iostream>
using namespace std;

void towerOfHanoi(int n, char source, char auxiliary, char destination) {
    if (n == 1) {
        cout << "Move disk 1 from " << source << " to " << destination << endl;
        return;
    }
    towerOfHanoi(n - 1, source, destination, auxiliary);
    cout << "Move disk " << n << " from " << source << " to " << destination << endl;
    towerOfHanoi(n - 1, auxiliary, source, destination);
}

int main() {
    int numDisks = 3;
    towerOfHanoi(numDisks, 'A', 'B', 'C');
    return 0;
}
18. Array Implementation of list (Create, insert, delete, modify, traversing, merging) 
#include<iostream>
using namespace std;

const int MAX_SIZE = 100;
int arr[MAX_SIZE];
int size = 0;

void createList(int elements[], int n) {
    size = n;
    for (int i = 0; i < n; ++i) {
        arr[i] = elements[i];
    }
}

void insertElement(int element, int position) {
    if (position < 0 || position > size) {
        cout << "Invalid position for insertion." << endl;
        return;
    }

    for (int i = size - 1; i >= position; --i) {
        arr[i + 1] = arr[i];
    }

    arr[position] = element;
    ++size;
}
void deleteElement(int position) {
    if (position < 0 || position >= size) {
        cout << "Invalid position for deletion." << endl;
        return;
    }

    for (int i = position; i < size - 1; ++i) {
        arr[i] = arr[i + 1]}
    --size;
}

void displayList() {
    for (int i = 0; i < size; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int elements[] = {1, 2, 3, 4, 5};
    createList(elements, 5);

    displayList();

    insertElement(10, 2);
    displayList();

    deleteElement(3);
    displayList();

    return 0;
}
20. Program to implement Doubly Linked List 
#include<iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

class DoublyLinkedList {
private:
    Node* head;

public:
    DoublyLinkedList() : head(nullptr) {}

    void insertAtFront(int value) {
        Node* newNode = new Node{value, nullptr, head};
        if (head != nullptr) {
            head->prev = newNode;
        }
        head = newNode;
    }

    void displayList() {
        Node* current = head;
        while (current != nullptr) {
            cout << current->data << " ";
            current = current->next;
        }
        cout << endl;
    }

    // Add other doubly linked list operations as needed
};

int main() {
    DoublyLinkedList myList;

    myList.insertAtFront(5);
    myList.insertAtFront(10);
    myList.insertAtFront(15);

    myList.displayList();

    return 0;
}
21. Program to implement Circular Linked List 
#include<iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

class CircularLinkedList {
private:
    Node* head;

public:
    CircularLinkedList() : head(nullptr) {}

    void insertAtFront(int value) {
        Node* newNode = new Node{value, nullptr};
        if (head == nullptr) {
            head = newNode;
            head->next = head;
        } else {
            newNode->next = head->next;
            head->next = newNode;
        }
    }

    void displayList() {
        if (head == nullptr) {
            cout << "List is empty." << endl;
            return;
        }

        Node* current = head->next;
        cout << head->data << " ";
        while (current != head) {
            cout << current->data << " ";
            current = current->next;
        }
        cout << endl;
    }

    // Add other circular linked list operations as needed
};

int main() {
    CircularLinkedList myList;

    myList.insertAtFront(5);
    myList.insertAtFront(10);
    myList.insertAtFront(15);

    myList.displayList();

    return 0;
}
22. Program to implement Bubble Sort 
#include<iostream>
using namespace std;

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                // Swap the elements
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    bubbleSort(arr, n);

    cout << "Sorted array: ";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
23. Program to implement Selection Sort
#include<iostream>
using namespace std;

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        // Swap the found minimum element with the first element
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    selectionSort(arr, n);

    cout << "Sorted array: ";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
24. Program to implement Insertion Sort 
#include<iostream>
using namespace std;

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;

        // Move elements of arr[0..i-1] that are greater than key to one position ahead of their current position
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            --j;
        }

        arr[j + 1] = key;
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    insertionSort(arr, n);

    cout << "Sorted array: ";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
25. Program to implement Shell Sort 
#include<iostream>
using namespace std;

void shellSort(int arr[], int n) {
    for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < n; ++i) {
            int temp = arr[i];
            int j;

            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }

            arr[j] = temp;
        }
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    shellSort(arr, n);

    cout << "Sorted array: ";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
26. Program to implement Merge Sort 
#include<iostream>
using namespace std;

void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;

    int leftArr[n1], rightArr[n2];

    for (int i = 0; i < n1; i++)
        leftArr[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        rightArr[j] = arr[m + 1 + j];

    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k] = leftArr[i];
            i++;
        } else {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;

        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        merge(arr, l, m, r);
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    mergeSort(arr, 0, n - 1);

    cout << "Sorted array: ";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
27. Program to implement Quick Sort 
#include<iostream>
using namespace std;

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j <= high - 1; ++j) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    quickSort(arr, 0, n - 1);

    cout << "Sorted array: ";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
28. Program to implement Heap Sort 
#include<iostream>
using namespace std;

void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest])
        largest = left;

    if (right < n && arr[right] > arr[largest])
        largest = right;

    if (largest != i) {
        swap(arr[i], arr[largest]);

        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; --i)
        heapify(arr, n, i);

    for (int i = n - 1; i > 0; --i) {
        swap(arr[0], arr[i]);

        heapify(arr, i, 0);
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    heapSort(arr, n);

    cout << "Sorted array: ";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
29. Program to implement Sequential Search 
#include<iostream>
using namespace std;

int sequentialSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; ++i) {
        if (arr[i] == key) {
            return i; // Key found at index i
        }
    }
    return -1; // Key not found
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 12;

    int result = sequentialSearch(arr, n, key);

    if (result != -1) {
        cout << "Element found at index: " << result << endl;
    } else {
        cout << "Element not found in the array." << endl;
    }

    return 0;
}
30. Program to implement Binary Search 
#include<iostream>
using namespace std;

int binarySearch(int arr[], int low, int high, int key) {
    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == key) {
            return mid; // Key found at index mid
        } else if (arr[mid] < key) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1; // Key not found
}

int main() {
    int arr[] = {11, 12, 22, 25, 64};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 25;

    int result = binarySearch(arr, 0, n - 1, key);

    if (result != -1) {
        cout << "Element found at index: " << result << endl;
    } else {
        cout << "Element not found in the array." << endl;
    }

    return 0;
}
31. Program to implement Linear Probing 
#include<iostream>
using namespace std;

const int SIZE = 10;

class LinearProbing {
private:
    int hashTable[SIZE];

public:
    LinearProbing() {
        for (int i = 0; i < SIZE; ++i) {
            hashTable[i] = -1;
        }
    }

    int hashFunction(int key) {
        return key % SIZE;
    }

    void insert(int key) {
        int index = hashFunction(key);

        while (hashTable[index] != -1) {
            index = (index + 1) % SIZE;
        }

        hashTable[index] = key;
    }

    void display() {
        for (int i = 0; i < SIZE; ++i) {
            cout << "Index " << i << ": ";
            if (hashTable[i] != -1) {
                cout << hashTable[i];
            }
            cout << endl;
        }
    }
};

int main() {
    LinearProbing hashTable;

    hashTable.insert(25);
    hashTable.insert(35);
    hashTable.insert(45);
    hashTable.insert(55);

    hashTable.display();

    return 0;
}
32. Program to implement Double Hashing 
#include<iostream>
using namespace std;

const int SIZE = 10;

class DoubleHashing {
private:
    int hashTable[SIZE];

public:
    DoubleHashing() {
        for (int i = 0; i < SIZE; ++i) {
            hashTable[i] = -1;
        }
    }

    int hashFunction1(int key) {
        return key % SIZE;
    }

    int hashFunction2(int key) {
        return 7 - (key % 7); // 7 is a prime number less than SIZE
    }

    void insert(int key) {
        int index = hashFunction1(key);

        if (hashTable[index] == -1) {
            hashTable[index] = key;
        } else {
            int index2 = hashFunction2(key);
            int i = 1;

            while (true) {
                int newIndex = (index + i * index2) % SIZE;

                if (hashTable[newIndex] == -1) {
                    hashTable[newIndex] = key;
                    break;
                }

                ++i;
            }
        }
    }

    void display() {
        for (int i = 0; i < SIZE; ++i) {
            cout << "Index " << i << ": ";
            if (hashTable[i] != -1) {
                cout << hashTable[i];
            }
            cout << endl;
        }
    }
};

int main() {
    DoubleHashing hashTable;

    hashTable.insert(25);
    hashTable.insert(35);
    hashTable.insert(45);
    hashTable.insert(55);

    hashTable.display();

    return 0;
}
33. Program to implement BST -Insertion 
#include<iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

Node* createNode(int key) {
    Node* newNode = new Node;
    newNode->data = key;
    newNode->left = newNode->right = nullptr;
    return newNode;
}

Node* insert(Node* root, int key) {
    if (root == nullptr) {
        return createNode(key);
    }

    if (key < root->data) {
        root->left = insert(root->left, key);
    } else if (key > root->data) {
        root->right = insert(root->right, key);
    }

    return root;
}

void inOrderTraversal(Node* root) {
    if (root != nullptr) {
        inOrderTraversal(root->left);
        cout << root->data << " ";
        inOrderTraversal(root->right);
    }
}

int main() {
    Node* root = nullptr;

    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);

    cout << "In-order traversal of the BST: ";
    inOrderTraversal(root);
    cout << endl;

    return 0;
}
34. Program to implement BST -Deletion 
#include<iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

Node* createNode(int key) {
    Node* newNode = new Node;
    newNode->data = key;
    newNode->left = newNode->right = nullptr;
    return newNode;
}

Node* insert(Node* root, int key) {
    if (root == nullptr) {
        return createNode(key);
    }

    if (key < root->data) {
        root->left = insert(root->left, key);
    } else if (key > root->data) {
        root->right = insert(root->right, key);
    }

    return root;
}

Node* findMinValueNode(Node* root) {
    while (root->left != nullptr) {
        root = root->left;
    }
    return root;
}

Node* deleteNode(Node* root, int key) {
    if (root == nullptr) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == nullptr) {
            Node* temp = root->right;
            delete root;
            return temp;
        } else if (root->right == nullptr) {
            Node* temp = root->left;
            delete root;
            return temp;
        }

        Node* minValueNode = findMinValueNode(root->right);
        root->data = minValueNode->data;
        root->right = deleteNode(root->right, minValueNode->data);
    }
    return root;
}

void inOrderTraversal(Node* root) {
    if (root != nullptr) {
        inOrderTraversal(root->left);
        cout << root->data << " ";
        inOrderTraversal(root->right);
    }
}

int main() {
    Node* root = nullptr;

    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);

    cout << "In-order traversal of the BST before deletion: ";
    inOrderTraversal(root);
    cout << endl;

    int keyToDelete = 30;
    root = deleteNode(root, keyToDelete);

    cout << "In-order traversal of the BST after deleting " << keyToDelete << ": ";
    inOrderTraversal(root);
    cout << endl;

    return 0;
}
35. Program to implement BST -Traversal 
#include<iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

Node* createNode(int key) {
    Node* newNode = new Node;
    newNode->data = key;
    newNode->left = newNode->right = nullptr;
    return newNode;
}

Node* insert(Node* root, int key) {
    if (root == nullptr) {
        return createNode(key);
    }

    if (key < root->data) {
        root->left = insert(root->left, key);
    } else if (key > root->data) {
        root->right = insert(root->right, key);
    }

    return root;
}

void inOrderTraversal(Node* root) {
    if (root != nullptr) {
        inOrderTraversal(root->left);
        cout << root->data << " ";
        inOrderTraversal(root->right);
    }
}

void preOrderTraversal(Node* root) {
    if (root != nullptr) {
        cout << root->data << " ";
        preOrderTraversal(root->left);
        preOrderTraversal(root->right);
    }
}

void postOrderTraversal(Node* root) {
    if (root != nullptr) {
        postOrderTraversal(root->left);
        postOrderTraversal(root->right);
        cout << root->data << " ";
    }
}

int main() {
    Node* root = nullptr;

    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);

    cout << "In-order traversal of the BST: ";
    inOrderTraversal(root);
    cout << endl;

    cout << "Pre-order traversal of the BST: ";
    preOrderTraversal(root);
    cout << endl;

    cout << "Post-order traversal of the BST: ";
    postOrderTraversal(root);
    cout << endl;

    return 0;
}
36. Program to implement BST -Searching 
#include<iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

Node* createNode(int key) {
    Node* newNode = new Node;
    newNode->data = key;
    newNode->left = newNode->right = nullptr;
    return newNode;
}

Node* insert(Node* root, int key) {
    if (root == nullptr) {
        return createNode(key);
    }

    if (key < root->data) {
        root->left = insert(root->left, key);
    } else if (key > root->data) {
        root->right = insert(root->right, key);
    }

    return root;
}

Node* search(Node* root, int key) {
    if (root == nullptr || root->data == key) {
        return root;
    }

    if (key < root->data) {
        return search(root->left, key);
    }

    return search(root->right, key);
}

int main() {
    Node* root = nullptr;

    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);

    int keyToSearch = 40;
    Node* result = search(root, keyToSearch);

    if (result != nullptr) {
        cout << "Element " << keyToSearch << " found in the BST." << endl;
    } else {
        cout << "Element " << keyToSearch << " not found in the BST." << endl;
    }

    return 0;
}
37. Program to insert element in AVL Tree 
#include<iostream>
#include<algorithm>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
    int height;
};

int getHeight(Node* node) {
    if (node == nullptr) {
        return 0;
    }
    return node->height;
}

int getBalanceFactor(Node* node) {
    if (node == nullptr) {
        return 0;
    }
    return getHeight(node->left) - getHeight(node->right);
}

Node* createNode(int key) {
    Node* newNode = new Node;
    newNode->data = key;
    newNode->left = newNode->right = nullptr;
    newNode->height = 1; // New node is initially at height 1
    return newNode;
}

Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;

    // Perform rotation
    x->right = y;
    y->left = T2;

    // Update heights
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    return x; // New root
}

Node* leftRotate(Node* x) {
    Node* y = x->right;
    Node* T2 = y->left;

    // Perform rotation
    y->left = x;
    x->right = T2;

    // Update heights
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    return y; // New root
}

Node* insert(Node* root, int key) {
    if (root == nullptr) {
        return createNode(key);
    }

    if (key < root->data) {
        root->left = insert(root->left, key);
    } else if (key > root->data) {
        root->right = insert(root->right, key);
    } else {
        // Duplicate keys are not allowed in AVL Tree
        return root;
    }

    // Update height of the current node
    root->height = 1 + max(getHeight(root->left), getHeight(root->right));

    // Get the balance factor to check if this node became unbalanced
    int balance = getBalanceFactor(root);

    // Left Left Case
    if (balance > 1 && key < root->left->data) {
        return rightRotate(root);
    }

    // Right Right Case
    if (balance < -1 && key > root->right->data) {
        return leftRotate(root);
    }

    // Left Right Case
    if (balance > 1 && key > root->left->data) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    // Right Left Case
    if (balance < -1 && key < root->right->data) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

void preOrderTraversal(Node* root) {
    if (root != nullptr) {
        cout << root->data << " ";
        preOrderTraversal(root->left);
        preOrderTraversal(root->right);
    }
}

int main() {
    Node* root = nullptr;

    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    cout << "Pre-order traversal of the AVL Tree: ";
    preOrderTraversal(root);
    cout << endl;

    return 0;
}
38. Program to implement BFS 
#include<iostream>
#include<queue>
using namespace std;

class Graph {
private:
    int vertices;
    int** adjacencyMatrix;

public:
    Graph(int v) : vertices(v) {
        adjacencyMatrix = new int*[v];
        for (int i = 0; i < v; ++i) {
            adjacencyMatrix[i] = new int[v];
            for (int j = 0; j < v; ++j) {
                adjacencyMatrix[i][j] = 0;
            }
        }
    }

    void addEdge(int start, int end) {
        adjacencyMatrix[start][end] = 1;
        adjacencyMatrix[end][start] = 1;
    }

    void breadthFirstSearch(int startVertex) {
        bool* visited = new bool[vertices];
        for (int i = 0; i < vertices; ++i) {
            visited[i] = false;
        }

        queue<int> q;
        visited[startVertex] = true;
        cout << "BFS starting from vertex " << startVertex << ": ";

        q.push(startVertex);

        while (!q.empty()) {
            int currentVertex = q.front();
            cout << currentVertex << " ";
            q.pop();

            for (int i = 0; i < vertices; ++i) {
                if (adjacencyMatrix[currentVertex][i] == 1 && !visited[i]) {
                    visited[i] = true;
                    q.push(i);
                }
            }
        }

        delete[] visited;
        cout << endl;
    }
};

int main() {
    Graph graph(6);

    graph.addEdge(0, 1);
    graph.addEdge(0, 2);
    graph.addEdge(1, 3);
    graph.addEdge(1, 4);
    graph.addEdge(2, 4);
    graph.addEdge(3, 5);
    graph.addEdge(4, 5);

    graph.breadthFirstSearch(0);

    return 0;
}
39. Program to implement DFS 
#include<iostream>
#include<stack>
using namespace std;

class Graph {
private:
    int vertices;
    int** adjacencyMatrix;

public:
    Graph(int v) : vertices(v) {
        adjacencyMatrix = new int*[v];
        for (int i = 0; i < v; ++i) {
            adjacencyMatrix[i] = new int[v];
            for (int j = 0; j < v; ++j) {
                adjacencyMatrix[i][j] = 0;
            }
        }
    }

    void addEdge(int start, int end) {
        adjacencyMatrix[start][end] = 1;
        adjacencyMatrix[end][start] = 1;
    }

    void depthFirstSearch(int startVertex) {
        bool* visited = new bool[vertices];
        for (int i = 0; i < vertices; ++i) {
            visited[i] = false;
        }

        stack<int> s;
        visited[startVertex] = true;
        cout << "DFS starting from vertex " << startVertex << ": ";

        s.push(startVertex);

        while (!s.empty()) {
            int currentVertex = s.top();
            cout << currentVertex << " ";
            s.pop();

            for (int i = 0; i < vertices; ++i) {
                if (adjacencyMatrix[currentVertex][i] == 1 && !visited[i]) {
                    visited[i] = true;
                    s.push(i);
                }
            }
        }

        delete[] visited;
        cout << endl;
    }
};

int main() {
    Graph graph(6);

    graph.addEdge(0, 1);
    graph.addEdge(0, 2);
    graph.addEdge(1, 3);
    graph.addEdge(1, 4);
    graph.addEdge(2, 4);
    graph.addEdge(3, 5);
    graph.addEdge(4, 5);

    graph.depthFirstSearch(0);

    return 0;
}
40. Program to implement Kruskal’s Algorithm 
#include<iostream>
#include<algorithm>
using namespace std;

struct Edge {
    int src, dest, weight;
};

class Graph {
private:
    int vertices, edges;
    Edge* edgeList;

public:
    Graph(int v, int e) : vertices(v), edges(e) {
        edgeList = new Edge[e];
    }

    void addEdge(int src, int dest, int weight, int index) {
        edgeList[index].src = src;
        edgeList[index].dest = dest;
        edgeList[index].weight = weight;
    }

    int find(int parent[], int i) {
        if (parent[i] == -1)
            return i;
        return find(parent, parent[i]);
    }

    void unionSets(int parent[], int x, int y) {
        int xset = find(parent, x);
        int yset = find(parent, y);
        parent[xset] = yset;
    }

    void kruskalMST() {
        Edge result[vertices];
        int e = 0; // Index used for the result array
        int i = 0; // Index used for the sorted edgeList

        // Sort edges in non-decreasing order by weight
        sort(edgeList, edgeList + edges, [](const Edge &a, const Edge &b) {
            return a.weight < b.weight;
        });

        int *parent = new int[vertices];
        fill(parent, parent + vertices, -1);

        while (e < vertices - 1 && i < edges) {
            Edge nextEdge = edgeList[i++];

            int x = find(parent, nextEdge.src);
            int y = find(parent, nextEdge.dest);

            if (x != y) {
                result[e++] = nextEdge;
                unionSets(parent, x, y);
            }
        }

        cout << "Edges in the Minimum Spanning Tree (Kruskal's Algorithm):" << endl;
        for (i = 0; i < e; ++i) {
            cout << result[i].src << " - " << result[i].dest << " (" << result[i].weight << ")" << endl;
        }

        delete[] parent;
    }
};

int main() {
    int vertices = 4;
    int edges = 5;
    Graph graph(vertices, edges);

    // Adding edges: source, destination, weight
    graph.addEdge(0, 1, 10, 0);
    graph.addEdge(0, 2, 6, 1);
    graph.addEdge(0, 3, 5, 2);
    graph.addEdge(1, 3, 15, 3);
    graph.addEdge(2, 3, 4, 4);

    graph.kruskalMST();

    return 0;
}
41. Program to implement Prim’s Algorithm 
#include<iostream>
#include<vector>
#include<climits>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjacencyMatrix;

public:
    Graph(int v) : vertices(v), adjacencyMatrix(v, vector<int>(v, 0)) {}

    void addEdge(int start, int end, int weight) {
        adjacencyMatrix[start][end] = weight;
        adjacencyMatrix[end][start] = weight;
    }

    int findMinKey(const vector<int> &key, const vector<bool> &mstSet) {
        int minKey = INT_MAX;
        int minIndex = -1;

        for (int v = 0; v < vertices; ++v) {
            if (!mstSet[v] && key[v] < minKey) {
                minKey = key[v];
                minIndex = v;
            }
        }

        return minIndex;
    }

    void primMST(int startVertex) {
        vector<int> parent(vertices, -1);
        vector<int> key(vertices, INT_MAX);
        vector<bool> mstSet(vertices, false);

        key[startVertex] = 0;

        for (int count = 0; count < vertices - 1; ++count) {
            int u = findMinKey(key, mstSet);

            mstSet[u] = true;

            for (int v = 0; v < vertices; ++v) {
                if (adjacencyMatrix[u][v] && !mstSet[v] && adjacencyMatrix[u][v] < key[v]) {
                    parent[v] = u;
                    key[v] = adjacencyMatrix[u][v];
                }
            }
        }

        cout << "Edges in the Minimum Spanning Tree (Prim's Algorithm):" << endl;
        for (int i = 1; i < vertices; ++i) {
            cout << parent[i] << " - " << i << " (" << key[i] << ")" << endl;
        }
    }
};

int main() {
    Graph graph(5);

    // Adding edges: source, destination, weight
    graph.addEdge(0, 1, 2);
    graph.addEdge(0, 3, 6);
    graph.addEdge(1, 2, 3);
    graph.addEdge(1, 3, 8);
    graph.addEdge(1, 4, 5);
    graph.addEdge(2, 4, 7);
    graph.addEdge(3, 4, 9);

    graph.primMST(0);

    return 0;
}
42. Program to implement Dijkstra’s Algorithm 
#include<iostream>
#include<vector>
#include<queue>
#include<climits>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<pair<int, int>>> adjacencyList;

public:
    Graph(int v) : vertices(v), adjacencyList(v) {}

    void addEdge(int start, int end, int weight) {
        adjacencyList[start].emplace_back(end, weight);
        adjacencyList[end].emplace_back(start, weight);
    }

    void dijkstraShortestPath(int startVertex) {
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        vector<int> distance(vertices, INT_MAX);

        pq.push({0, startVertex});
        distance[startVertex] = 0;

        while (!pq.empty()) {
            int u = pq.top().second;
            pq.pop();

            for (const auto &neighbor : adjacencyList[u]) {
                int v = neighbor.first;
                int weight = neighbor.second;

                if (distance[u] + weight < distance[v]) {
                    distance[v] = distance[u] + weight;
                    pq.push({distance[v], v});
                }
            }
        }

        cout << "Shortest distances from vertex " << startVertex << " (Dijkstra's Algorithm):" << endl;
        for (int i = 0; i < vertices; ++i) {
            cout << "Vertex " << i << ": " << distance[i] << endl;
        }
    }
};

int main() {
    Graph graph(5);

    // Adding edges: source, destination, weight
    graph.addEdge(0, 1, 2);
    graph.addEdge(0, 3, 1);
    graph.addEdge(1, 2, 3);
    graph.addEdge(1, 3, 2);
    graph.addEdge(1, 4, 5);
    graph.addEdge(2, 4, 1);
    graph.addEdge(3, 4, 4);

    graph.dijkstraShortestPath(0);

    return 0;
}
